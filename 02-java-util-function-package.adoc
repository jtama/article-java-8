== Consumer, supplier, Function and many others

Les interfaces qui peuvent être implémentées sous la forme de lambdas ne possèdent qu'une unique méthode abstraite. Elles sont appelées interfaces fonctionnelles et peuvent être annotées `@FunctionalInterface`. Cette annotation permet au compilateur de vérifier que l'interface est bien fonctionnelle, mais elle n'est en aucun cas obligatoire.

La classe `Comparator<T>` est un exemple d'interface fonctionnelle commune aux développeurs : sa méthode `compare(param1,param2)` renvoie le résultat de la comparaison entre deux objets de type `T`. Elle existait certes avant java 8, mais cette dernière version l'a dotée de l'annotation `@FunctionalInterface` pour la désigner comme telle.

Nous avons jusqu'ici utilisé des expressions lambdas pour implémenter des interfaces  courantes comme RowMapper, Comparator ou Runnable. Mais les lambdas sont plus largement utilisées pour définir des méthodes à l'endroit même où elles sont utilisées, sans porter d'intérêt particulier à l'interface fonctionnelle sous-jacente. Il est possible de vouloir déclarer de telles méthodes lorsqu'elles ne sont utilisées qu'une fois par exemple, ou encore pour passer un traitement en paramètre d'un autre traitement.
La méthode que l'on souhaite définir via une lambda doit ici encore implémenter une interface fonctionnelle. Java 8 fournit une bibliothèque d'interfaces fonctionnelles standard appelée java.util.function, qui permet au développeur d'avoir accès aux interfaces fonctionnelles les plus communes sans les définir lui-même.

=== L'essentiel
Les interfaces du package `java.util.function` (naissance avec Java 8) sont des fonctions génériques définissant les cas d'usages les plus courants:

- Une _function_ prendra un ou plusieurs paramètres en entrée et retournera un résultat.
- Un _supplier_ ne prendra pas de paramètre d'entrée et fournira un résultat.
- Un _consumer_ prendra un ou plusieurs paramètres d'entrée et ne renverra aucun résultat.
- Un _operator_ prendra un ou plusieurs paramètres du même type et fournira un retour de ce type.
- Un _predicate_ prendra un ou plusieurs paramètres en entrée et retournera un booléen.

=== Plus en détail

==== Des plus basiques ...

- `Function<T,R>` : désigne une fonction prenant un paramètre d'entrée de type `T` et retournant un objet de type `R`.

[source]
----
Function<Integer, String> getNumber = entier -> "Number " + entier;
----

Elle s'applique en utilisant apply :

[source]
----
>> getNumber.apply(1); \\ renvoie Number 1
----

- `Consumer<T>` : désigne une fonction prenant un paramètre d'entrée de type `T` et de type de retour `void`.

[source]
----
Consumer<Integer> display = entier -> System.out.println("Number " + entier);
----

Elle s'applique en utilisant apply :

[source]
----
>> display.apply(1); \\ affiche Number 1
----

- `Supplier<R>` : désigne une fonction ne prenant aucun paramètre d'entrée et retournant un objet de type `R`.

[source]
----
Supplier<Double> randomFrom0To100 = () -> Math.random() * 100;
----

Elle s'applique en utilisant get :

[source]
----
>> randomFrom0To100.get(); \\ affiche un double aléatoire en 0 et 100
----

- `Predicate<T>` : désigne une fonction prenant un paramètre d'entrée de type `T` et renvoyant un booléen.

Exemple :

[source]
----
Predicate<String> isNull = (str) -> str == null;
----

Elle s'applique en utilisant test :

[source]
----
>> isNull.test("HelloJava8"); // renvoie faux
----

==== ... Aux plus spécifiques

- `UnaryOperator<T>` : représente une fonction dont les types d'entrée et de retour sont identiques. C'est donc une `Function<T,T>`.
- `BiFunction<T,U,R>`, `BiConsumer<T,U>` : prennent en entrée deux paramètres, le premier de type `T` et le second de type `U`.
- `BinaryOperator<T>` : prend en entrée deux paramètres de type `T`. C'est donc une `BiFunction<T,T,T>`.
Par exemple :

[source]
----
BinaryOperator<Integer> add = (a,b) -> a+b;
----

- `IntFunction<R>`, `IntConsumer` dont le type du paramètre d'entrée est `int`. `IntSupplier` dont le type de retour est `int`. Et les autres dérivés sur le même modèle : `DoubleFunction<R>`, `DoubleConsumer`, `DoubleSupplier`, `DoubleUnaryOperator`, `LongFunction<R>`, etc.
- `ToIntFunction<T>` dont le type de retour est `int`, et ses dérivés : `ToIntBiFunction<T,U>`, `ToLongFunction<T>`, `ToLongBiFunction<T,U>`, `ToDoubleFunction<T>`, etc.


